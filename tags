!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALPHA	lexer.h	/^    ALPHA,$/;"	e	enum:TOKEN_TYPES
COMMA	lexer.h	/^    COMMA,$/;"	e	enum:TOKEN_TYPES
DIGIT	lexer.h	/^    DIGIT,$/;"	e	enum:TOKEN_TYPES
EMPTY	lexer.h	/^    EMPTY,$/;"	e	enum:TOKEN_TYPES
EQUALS	lexer.h	/^    EQUALS,$/;"	e	enum:TOKEN_TYPES
FLOAT	lexer.h	/^    FLOAT,$/;"	e	enum:TOKEN_TYPES
FUNCTION	lexer.h	/^    FUNCTION,$/;"	e	enum:TOKEN_TYPES
IDENTIFIER	lexer.h	/^    IDENTIFIER,$/;"	e	enum:TOKEN_TYPES
INT	lexer.h	/^    INT,$/;"	e	enum:TOKEN_TYPES
JSCRIPT_H	jscript.h	/^#define JSCRIPT_H$/;"	d
JSContext	jsvalue.cpp	/^JSContext::JSContext() {$/;"	f	class:JSContext
JSContext	jsvalue.h	/^class JSContext {$/;"	c
JSOBJECT_H	jsvalue.h	/^#define JSOBJECT_H$/;"	d
JSScopeChain	jsvalue.h	/^        std::vector<std::vector<JSValueHandlePtr>> JSScopeChain;$/;"	m	class:JSContext
JSVALUE_FLAGS	jsvalue.h	/^enum JSVALUE_FLAGS {$/;"	g
JSVALUE_FLOAT	jsvalue.h	/^    JSVALUE_FLOAT       = 4,$/;"	e	enum:JSVALUE_FLAGS
JSVALUE_FUNCTION	jsvalue.h	/^    JSVALUE_FUNCTION    = 8,$/;"	e	enum:JSVALUE_FLAGS
JSVALUE_INT	jsvalue.h	/^    JSVALUE_INT         = 2,$/;"	e	enum:JSVALUE_FLAGS
JSVALUE_STRING	jsvalue.h	/^    JSVALUE_STRING      = 1,$/;"	e	enum:JSVALUE_FLAGS
JSVALUE_UNDEFINED	jsvalue.h	/^    JSVALUE_UNDEFINED   = 0,$/;"	e	enum:JSVALUE_FLAGS
JSValue	jsvalue.cpp	/^JSValue::JSValue() {$/;"	f	class:JSValue
JSValue	jsvalue.cpp	/^JSValue::JSValue(float data, JSVALUE_FLAGS flags) {$/;"	f	class:JSValue
JSValue	jsvalue.cpp	/^JSValue::JSValue(int data, JSVALUE_FLAGS flags) {$/;"	f	class:JSValue
JSValue	jsvalue.cpp	/^JSValue::JSValue(std::string data, JSVALUE_FLAGS flags) {$/;"	f	class:JSValue
JSValue	jsvalue.h	/^class JSValue {$/;"	c
JSValueCache	jsvalue.h	/^        std::vector<JSValuePtr> JSValueCache;$/;"	m	class:JSContext
JSValueHandle	jsvalue.cpp	/^JSValueHandle::JSValueHandle(JSValue *value, const std::string name) {$/;"	f	class:JSValueHandle
JSValueHandle	jsvalue.h	/^class JSValueHandle {$/;"	c
JSValueHandlePtr	jsvalue.h	/^typedef std::shared_ptr<JSValueHandle> JSValueHandlePtr;$/;"	t
JSValuePtr	jsvalue.h	/^typedef std::shared_ptr<JSValue> JSValuePtr;$/;"	t
JScript	jscript.h	/^class JScript {$/;"	c
LEXER_H	lexer.h	/^#define LEXER_H$/;"	d
L_BRACKET	lexer.h	/^    L_BRACKET,$/;"	e	enum:TOKEN_TYPES
L_PAR	lexer.h	/^    L_PAR,$/;"	e	enum:TOKEN_TYPES
Lexer	lexer.cpp	/^Lexer::Lexer() {$/;"	f	class:Lexer
Lexer	lexer.h	/^class Lexer {$/;"	c
LexerException	lexer.h	/^        LexerException(const std::string _msg, int column) {$/;"	f	class:LexerException
LexerException	lexer.h	/^class LexerException : std::exception$/;"	c
MAX_LINE_LENGTH	jscript.cpp	/^#define MAX_LINE_LENGTH /;"	d	file:
OPERATOR	lexer.h	/^    OPERATOR,$/;"	e	enum:TOKEN_TYPES
R_BRACKET	lexer.h	/^    R_BRACKET,$/;"	e	enum:TOKEN_TYPES
R_PAR	lexer.h	/^    R_PAR,$/;"	e	enum:TOKEN_TYPES
SEMICOLON	lexer.h	/^    SEMICOLON,$/;"	e	enum:TOKEN_TYPES
STRING	lexer.h	/^    STRING,$/;"	e	enum:TOKEN_TYPES
TOKEN_TYPES	lexer.h	/^enum TOKEN_TYPES {$/;"	g
VAR	lexer.h	/^    VAR,$/;"	e	enum:TOKEN_TYPES
_EOF_	lexer.h	/^    _EOF_$/;"	e	enum:TOKEN_TYPES
addChild	jsvalue.cpp	/^void JSContext::addChild(JSValueHandlePtr value) {$/;"	f	class:JSContext
arithmetic	jsvalue.cpp	/^JSValuePtr JSValue::arithmetic(JSValuePtr value, char op) {$/;"	f	class:JSValue
assignment	jscript.cpp	/^void JScript::assignment() {$/;"	f	class:JScript
backup	lexer.cpp	/^void Lexer::backup() {$/;"	f	class:Lexer
base	jscript.cpp	/^JSValuePtr JScript::base() {$/;"	f	class:JScript
buffer	lexer.h	/^        std::string buffer;$/;"	m	class:Lexer
bytesRemaining	jscript.h	/^        int bytesRemaining() { return lexer.buffer.size(); }$/;"	f	class:JScript
currentChr	lexer.cpp	/^char Lexer::currentChr() {$/;"	f	class:Lexer
cxt	jscript.h	/^    JSContext cxt;$/;"	m	class:JScript
data	jsvalue.h	/^        std::string data;$/;"	m	class:JSValue
defineFunction	jscript.cpp	/^void JScript::defineFunction() {$/;"	f	class:JScript
defineLambdaFunction	jscript.cpp	/^JSValuePtr JScript::defineLambdaFunction() {$/;"	f	class:JScript
digit	jscript.cpp	/^JSValuePtr JScript::digit() {$/;"	f	class:JScript
end_position	lexer.h	/^        int end_position;$/;"	m	class:Lexer
error	lexer.cpp	/^void Lexer::error() {$/;"	f	class:Lexer
error	lexer.cpp	/^void Lexer::error(const std::string msg) {$/;"	f	class:Lexer
execute	jscript.cpp	/^JSValuePtr JScript::execute(std::string line) {$/;"	f	class:JScript
execute	jsvalue.cpp	/^JSValuePtr JSValue::execute() {$/;"	f	class:JSValue
factor	jscript.cpp	/^JSValuePtr JScript::factor() {$/;"	f	class:JScript
findChild	jsvalue.cpp	/^JSValueHandlePtr JSContext::findChild(std::string name) {$/;"	f	class:JSContext
flags	jsvalue.h	/^        int flags;$/;"	m	class:JSValue
floatData	jsvalue.h	/^        float floatData;$/;"	m	class:JSValue
getCurrentTokenStr	lexer.cpp	/^std::string Lexer::getCurrentTokenStr() {$/;"	f	class:Lexer
getFloat	jsvalue.cpp	/^float JSValue::getFloat() {$/;"	f	class:JSValue
getInt	jsvalue.cpp	/^int JSValue::getInt() {$/;"	f	class:JSValue
getString	jsvalue.cpp	/^std::string JSValue::getString() {$/;"	f	class:JSValue
intData	jsvalue.h	/^        int intData;$/;"	m	class:JSValue
isAlpha	lexer.cpp	/^bool Lexer::isAlpha() {$/;"	f	class:Lexer
isDigit	lexer.cpp	/^bool Lexer::isDigit() {$/;"	f	class:Lexer
isFloat	jsvalue.h	/^        bool isFloat()      { return (flags & JSVALUE_FLOAT) != 0; };$/;"	f	class:JSValue
isFunction	jsvalue.h	/^        bool isFunction()   { return (flags & JSVALUE_FUNCTION) != 0; };$/;"	f	class:JSValue
isInt	jsvalue.h	/^        bool isInt()        { return (flags & JSVALUE_INT) != 0; };$/;"	f	class:JSValue
isString	jsvalue.h	/^        bool isString()     { return (flags & JSVALUE_STRING) != 0; };$/;"	f	class:JSValue
isUndefined	jsvalue.h	/^        bool isUndefined()  { return (flags & JSVALUE_UNDEFINED) != 0; };$/;"	f	class:JSValue
lexer	jscript.h	/^    Lexer lexer;$/;"	m	class:JScript
load	lexer.cpp	/^void Lexer::load(std::string &line) {$/;"	f	class:Lexer
main	jscript.cpp	/^int main() {$/;"	f
marked	jsvalue.h	/^        bool marked;$/;"	m	class:JSValue
match	lexer.cpp	/^bool Lexer::match(TOKEN_TYPES type) {$/;"	f	class:Lexer
mathExp	jscript.cpp	/^JSValuePtr JScript::mathExp(JSValuePtr &start) {$/;"	f	class:JScript
mathOp	jsvalue.cpp	/^T mathOp(T a, T b, char op) {$/;"	f
msg	lexer.h	/^        std::string msg;$/;"	m	class:LexerException
name	jsvalue.h	/^        std::string name;$/;"	m	class:JSValueHandle
next	lexer.cpp	/^void Lexer::next() {$/;"	f	class:Lexer
nextToken	lexer.cpp	/^void Lexer::nextToken() {$/;"	f	class:Lexer
peek	lexer.cpp	/^char Lexer::peek() {$/;"	f	class:Lexer
popScope	jsvalue.cpp	/^void JSContext::popScope() {$/;"	f	class:JSContext
prevToken	lexer.cpp	/^void Lexer::prevToken() {$/;"	f	class:Lexer
prev_position	lexer.h	/^        int prev_position;$/;"	m	class:Lexer
prev_substr	lexer.h	/^        std::string prev_substr;$/;"	m	class:Lexer
prev_token	lexer.h	/^        TOKEN_TYPES prev_token;$/;"	m	class:Lexer
pushScope	jsvalue.cpp	/^void JSContext::pushScope() {$/;"	f	class:JSContext
reset	lexer.cpp	/^void Lexer::reset() {$/;"	f	class:Lexer
save	lexer.cpp	/^void Lexer::save() {$/;"	f	class:Lexer
saveAndNext	lexer.cpp	/^void Lexer::saveAndNext() {$/;"	f	class:Lexer
skipWhiteSpace	lexer.cpp	/^void Lexer::skipWhiteSpace() {$/;"	f	class:Lexer
str	jsvalue.cpp	/^std::string JSValue::str() {$/;"	f	class:JSValue
substr	lexer.h	/^        std::string substr;$/;"	m	class:Lexer
token	lexer.h	/^        TOKEN_TYPES token;$/;"	m	class:Lexer
value	jsvalue.h	/^        JSValuePtr value;$/;"	m	class:JSValueHandle
